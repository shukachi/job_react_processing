Здравствуйте! Проанализировав предоставленные файлы, я подготовил пошаговый план и код для преобразования вашего статичного сайта в полноценное React-приложение, которое будет взаимодействовать с бэкендом по REST API и запускаться с помощью Docker.

Это комплексная задача, поэтому я разбил ее на логические этапы.

### Этап 1: Структура проекта

Мы создадим монорепозиторий с двумя основными папками: `frontend` для React-приложения и `backend` (в качестве заглушки) для будущего серверного приложения.

```
simona-home-react/
├── docker-compose.yml      # Файл для оркестрации фронтенд и бэкенд контейнеров
├── frontend/
│   ├── Dockerfile          # Инструкции для сборки Docker-образа React-приложения
│   ├── nginx.conf          # Конфигурация Nginx для раздачи статики
│   ├── package.json        # Зависимости и скрипты фронтенда
│   ├── public/             # Статические файлы (HTML, изображения)
│   │   ├── index.html
│   │   ├── reset.css
│   │   └── img/            # <-- Скопируйте сюда все ваши изображения
│   └── src/
│       ├── App.css         # Ваши стили из styles.css
│       ├── App.js          # Главный компонент приложения
│       ├── index.js        # Точка входа в React-приложение
│       └── components/     # Папка с React-компонентами
│           ├── Header.js
│           ├── Sidebar.js
│           ├── About.js
│           ├── Location.js
│           ├── House.js
│           ├── Services.js
│           ├── Booking.js      # Компонент с логикой REST API
│           ├── Contacts.js
│           └── Reviews.js      # Компонент с логикой REST API
└── backend/
    ├── Dockerfile          # Пример Dockerfile для бэкенда
    └── ...                 # Файлы вашего будущего бэкенда (например, на Node.js/Express)
```

### Этап 2: Настройка Docker

Docker позволит нам легко разворачивать и запускать приложение в изолированном окружении.

#### 1. Dockerfile для Frontend

Этот файл описывает, как собрать образ для нашего React-приложения. Он использует многоступенчатую сборку: первая ступень собирает статические файлы, а вторая — использует легковесный веб-сервер Nginx для их раздачи.

**`frontend/Dockerfile`**
```dockerfile
# Stage 1: Сборка React-приложения
FROM node:18-alpine as build

WORKDIR /app

# Копируем package.json и устанавливаем зависимости
COPY package.json ./
# Если у вас есть package-lock.json, раскомментируйте следующую строку
# COPY package-lock.json ./
RUN npm install

# Копируем исходный код
COPY . .

# Собираем production-билд
RUN npm run build

# Stage 2: Раздача статики через Nginx
FROM nginx:stable-alpine

# Копируем кастомную конфигурацию Nginx
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Копируем собранные файлы из стадии 'build'
COPY --from=build /app/build /usr/share/nginx/html

# Открываем порт 80
EXPOSE 80

# Запускаем Nginx
CMD ["nginx", "-g", "daemon off;"]
```

#### 2. Конфигурация Nginx

Nginx будет не только отдавать статику, но и правильно обрабатывать клиентский роутинг, а также проксировать запросы к нашему бэкенду.

**`frontend/nginx.conf`**
```nginx
server {
    listen 80;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        # Эта строка важна для работы React Router
        try_files $uri $uri/ /index.html;
    }

    # Проксируем все запросы, начинающиеся с /api/, на бэкенд сервис
    # 'backend' - это имя сервиса из docker-compose.yml, 8000 - его порт
    location /api/ {
        proxy_pass http://backend:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
```

#### 3. Docker Compose

Этот файл объединяет наши фронтенд и бэкенд сервисы, позволяя запустить их одной командой.

**`docker-compose.yml`**
```yaml
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
    ports:
      - "3000:80" # Маппим порт 80 контейнера на порт 3000 хоста
    depends_on:
      - backend
    networks:
      - simona-net

  backend:
    build:
      context: ./backend # Укажите путь к вашему бэкенду
    # Пример для Node.js:
    # command: npm start
    ports:
      - "8000:8000" # Открываем порт бэкенда для прямого доступа (опционально)
    environment:
      # Здесь можно задать переменные окружения для бэкенда
      DATABASE_URL: postgresql://user:password@db:5432/mydatabase
    networks:
      - simona-net
    # depends_on:
    #   - db # Если у вас есть база данных

networks:
  simona-net:
    driver: bridge
```

### Этап 3: Преобразование кода в React

Теперь перенесем вашу верстку и логику в React-компоненты. Я покажу ключевые моменты на примере компонентов `App`, `Booking` и `Reviews`, где будет происходить взаимодействие с API.

#### 1. Подготовка
Сначала создайте React-приложение в папке `frontend`:
```bash
npx create-react-app frontend
cd frontend
```
Установите `axios` для HTTP-запросов:
```bash
npm install axios
```
Затем перенесите `reset.css` в `frontend/public/` и `styles.css` в `frontend/src/App.css`. Также скопируйте папку `img` в `frontend/public/`.

#### 2. Основной компонент `App.js`
Он будет служить каркасом, собирая все секции в единое целое.

**`frontend/src/App.js`**
```javascript
import './App.css'; // Ваши основные стили

// Импортируем компоненты-секции
import Header from './components/Header';
import Sidebar from './components/Sidebar';
import About from './components/About';
import Location from './components/Location';
import House from './components/House';
import Services from './components/Services';
import Booking from './components/Booking';
import Contacts from './components/Contacts';
import Reviews from './components/Reviews';

function App() {
  // Список секций для навигации
  const navItems = [
    { id: 'about', title: 'О нас' },
    { id: 'nearby', title: 'Местоположение' },
    { id: 'house', title: 'Домик' },
    { id: 'services', title: 'Доп услуги' },
    { id: 'booking', title: 'Бронирование' },
    { id: 'contacts', title: 'Контакты и соцсети' },
    { id: 'reviews', title: 'Отзывы' },
  ];

  return (
    <div className="palette-nature">
      <Header />
      <div className="container">
        <Sidebar navItems={navItems} />
        <main className="content">
          <About />
          <Location />
          <House />
          <Services />
          <Booking />
          <Contacts />
          <Reviews />
        </main>
      </div>
    </div>
  );
}

export default App;
```

#### 3. Компонент `Booking.js` с REST API
Здесь мы заменяем моковую логику на реальные запросы к бэкенду.

**`frontend/src/components/Booking.js`**
```javascript
import React, { useState } from 'react';
import axios from 'axios';

const Booking = () => {
  const [step, setStep] = useState(1);
  const [dates, setDates] = useState({ checkin: '', checkout: '' });
  const [form, setForm] = useState({ name: '', phone: '', guests: 2 });
  const [services, setServices] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const handleCheckAvailability = async () => {
    if (!dates.checkin || !dates.checkout) {
      setError('Пожалуйста, выберите даты заезда и выезда.');
      return;
    }
    setLoading(true);
    setError('');
    try {
      // Запрос к API бэкенда
      const response = await axios.post('/api/booking/check-availability', dates);
      if (response.data.available) {
        setSuccess('Даты свободны! Переходим к заполнению данных.');
        setTimeout(() => {
          setSuccess('');
          setStep(2);
        }, 1500);
      } else {
        setError('К сожалению, выбранные даты уже заняты.');
      }
    } catch (err) {
      setError('Произошла ошибка при проверке дат. Попробуйте позже.');
    } finally {
      setLoading(false);
    }
  };

  const handleFormSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    try {
      const bookingData = { ...dates, ...form, services };
      // Отправляем заявку на бронирование
      await axios.post('/api/booking/create', bookingData);
      alert('Ваша заявка на бронирование отправлена! Мы свяжемся с вами в ближайшее время.');
      // Сброс формы
      setStep(1);
      setDates({ checkin: '', checkout: '' });
    } catch (err) {
      setError('Не удалось отправить заявку. Пожалуйста, попробуйте еще раз.');
    } finally {
      setLoading(false);
    }
  };

  // ... JSX разметка для формы бронирования ...
  // Используйте состояния (dates, form, services) и обработчики (handleCheckAvailability, handleFormSubmit)
  // для управления формой. Вместо прямого манипулирования DOM, как в script.js,
  // мы будем рендерить JSX в зависимости от состояния.

  return (
    <section id="booking" className="section">
      {/* Здесь будет JSX-разметка, адаптированная из simona-home.html */}
      {/* Например: */}
      <div className="booking-container">
        <h2 className="booking-title">Бронирование</h2>
        <div className="divider"></div>

        {error && <div className="error-message" style={{ display: 'block' }}>{error}</div>}
        {success && <div className="success-message" style={{ display: 'block' }}>{success}</div>}

        {step === 1 && (
          <div>
            {/* Форма выбора дат */}
            <div className="date-check-form">
              {/* ... поля для дат ... */}
              <button onClick={handleCheckAvailability} disabled={loading} className="btn btn-primary">
                {loading ? 'Проверка...' : 'Проверить доступность'}
              </button>
            </div>
          </div>
        )}

        {step === 2 && (
          <div>
            {/* Форма контактных данных и отправки */}
            <form onSubmit={handleFormSubmit}>
              {/* ... поля для имени, телефона, услуг ... */}
              <button type="submit" disabled={loading} className="btn btn-primary">
                {loading ? 'Отправка...' : 'Отправить бронь'}
              </button>
            </form>
          </div>
        )}
      </div>
    </section>
  );
};

export default Booking;
```

#### 4. Компонент `Reviews.js` с REST API
Здесь мы получаем отзывы с сервера при загрузке компонента и отправляем новые.

**`frontend/src/components/Reviews.js`**
```javascript
import React, { useState, useEffect } from 'react';
import axios from 'axios';

const Reviews = () => {
  const [reviews, setReviews] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  // Загрузка отзывов при монтировании компонента
  useEffect(() => {
    const fetchReviews = async () => {
      try {
        setLoading(true);
        const response = await axios.get('/api/reviews');
        setReviews(response.data);
      } catch (err) {
        setError('Не удалось загрузить отзывы.');
        // Можно загрузить моковые данные в случае ошибки
        // setReviews(mockReviews);
      } finally {
        setLoading(false);
      }
    };

    fetchReviews();
  }, []); // Пустой массив зависимостей означает, что эффект выполнится один раз

  const handleAddReview = async (reviewData) => {
    try {
      const response = await axios.post('/api/reviews', reviewData);
      // Добавляем новый отзыв в начало списка
      setReviews([response.data, ...reviews]);
      alert('Спасибо за ваш отзыв! Он будет опубликован после модерации.');
    } catch (err) {
      alert('Не удалось отправить отзыв.');
    }
  };

  if (loading) {
    return <section id="reviews" className="section"><div>Загрузка отзывов...</div></section>;
  }

  if (error) {
    return <section id="reviews" className="section"><div>{error}</div></section>;
  }

  // ... JSX разметка для отображения отзывов (reviews.map(...)) и формы добавления ...
  // Форма добавления отзыва будет вызывать handleAddReview при отправке.

  return (
    <section id="reviews" className="section">
      <div className="reviews-container">
        <h2 className="section-title center">Отзывы наших гостей</h2>
        <div className="divider"></div>
        <div className="reviews-slider">
          <div className="reviews-track">
            {reviews.map((review, index) => (
              <div key={index} className="review-card">
                <div className="review-header">
                  <div className="review-date">{review.date}</div>
                </div>
                <div className="review-rating">
                  {'★'.repeat(review.rating).padEnd(5, '☆')}
                </div>
                <div className="review-text">{review.text}</div>
              </div>
            ))}
          </div>
        </div>
        {/* Здесь должна быть форма добавления отзыва, которая вызывает handleAddReview */}
      </div>
    </section>
  );
};

export default Reviews;
```

### Этап 4: Запуск

1.  **Создайте `Dockerfile` для бэкенда.** Даже если он пустой, он нужен для `docker-compose`. Например, для Node.js:
    **`backend/Dockerfile`**
    ```dockerfile
    FROM node:18-alpine
    WORKDIR /app
    COPY package*.json ./
    RUN npm install
    COPY . .
    EXPOSE 8000
    CMD ["npm", "start"]
    ```
2.  **Перейдите в корневую папку `simona-home-react`**.
3.  **Запустите сборку и запуск контейнеров:**
    ```bash
    docker-compose up --build
    ```
4.  **Откройте браузер** и перейдите по адресу `http://localhost:3000`.

Вы увидите ваше React-приложение. Все запросы на `/api/...` будут автоматически перенаправляться на ваш бэкенд-сервис, работающий внутри другого Docker-контейнера.

Этот подход обеспечивает чистое разделение фронтенда и бэкенда, упрощает разработку и развертывание, а также создает масштабируемую архитектуру для вашего проекта.

---
Я не стал приводить код для всех компонентов (`About.js`, `Contacts.js` и т.д.), так как они в основном содержат статическую JSX-разметку, которую легко адаптировать из вашего `simona-home.html`. Главное — я показал, как перестроить ключевые интерактивные части на React и связать их с бэкендом.

---
проанализируй файлы: simona-home.html,styles.css,script.js и собери поэтапный react file с помощью докера который контактирует с бэкэнд айлом по restip